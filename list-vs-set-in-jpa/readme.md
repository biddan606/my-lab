# JPA 연관관계별 List vs Set

@ManyToMany, @OneToMany(One이 관계의 주인인 상황, Many가 관계의 주인인 상황)   총 3가지 경우별 List와 Set일 때의 쿼리를 비교합니다.

## @ManyToMany

학생-수업(Course) 엔티티가 서로 ManyToMany 관계를 맺고 있습니다.
학생 1명이 여러 개의 수업을 듣고 있는 상황에서의 결과입니다.

### 삽입(학생-코스 연결)

- **Set**: 학생에 연결된 모든 코스를 가져온 뒤, 학생-코스를 매핑합니다.
- **List**:
    1. 학생의 모든 코스를 가져옵니다.
    2. 학생의 모든 코스 관계를 제거합니다.
    3. 제거했던 모든 코스 관계와 추가할 학생-코스 관계를 추가합니다.

### 삭제(연결 해제)

- **Set**: 특이사항X
- **List**: 삽입과 동일하게 많은 쿼리 발생

### 변경

- **Set**: 특이사항X
- **List**: 특이사항X

@ManyToMany 관계에서 List로 설정할 경우, 매우 비효율적으로 동작한다는 걸 알 수 있었습니다.   
정확한 이유는 알 수 없지만, 중간 엔티티가 부족하여 매핑 테이블을 제대로 알 수 없지만, List이므로 순서를 보장해주려 하다보니 이와 같이 비효율적으로 동작하는 것으로
보입니다.   
**List 사용시 비효율적 쿼리 개선 방법**: `@OrderColumn` 으로 순서를 지정해주면 비효율적인 쿼리를 사용하지 않고 Set과 동일하게 동작합니다.

## @OneToMany(One이 관계의 주인인 상황)

Department(부서)-Employee(직원)이 OneToMany 관계를 맺고 있습니다. 엔티티에서 부서가 관계의 주인입니다.   
1개의 부서에 5명의 직원이 속한 상황입니다.

### 삽입(직원 추가와 매핑)

- **Set**:
    1. 해당 부서에 속학 직원을 모두 가져옵니다.
    2. 직원을 추가합니다.
    3. 직원-부서 매핑합니다.(직원 추가와 직원-)
- **List**: Set과 동일한 쿼리

### 삭제(연결 해제 및 직원 제거)

- **Set**:
    1. 직원 매핑 끊기
    2. 직원 제거
- **List**: Set과 동일 쿼리

### 변경

- **Set**: 특이사항X
- **List**: 특이사항X

엔티티상의 관계의 주인과 DB에서 가지고 있는 외래키의 주인이 달라 직원 추가시 쿼리가 2개로 나뉘어져 나가는 문제가 있습니다.

## @OneToMany(Many가 관계의 주인인 상황)

Author(저자)-Book(책)이 OneToMany 관계를 맺고 있습니다.   
책이 엔티티 관계의 주인이고 DB의 외래키 주인과 동일합니다.   
저자 1명이 5권의 책과 매핑되어 있는 상황입니다.

### 삽입(저자와 책 매핑)

- **Set**: author.books에 값을 삽입할 때, 저자의 책들을 불러옵니다.
- **List**: 추가 쿼리 X

### 삭제(연결 해제)

- **Set**: 추가 쿼리 X
- **List**: 추가 쿼리 X

OneToMany에서 One은 `mapped` 로 기본적으로 읽기 전용입니다.   
그래서 `add` 시에는 매핑된 값들을 가져올 필요가 없지만 Set으로 설정시에는 가져옵니다.   
`Set.add()` 는 삽입시 중복을 제거해야 하는데, 중복을 제거하기 위해서는 기본 데이터에 중복이 있는지 비교해야 합니다. 이러한 이유 때문에 컬렉션을 조회해옵니다.

## 결론

- @ManyToMany 테스트를 해보면서 엔티티를 추적할 수 없는 테이블을 만드는 것이 매우 위험하다는 것을 알 수 있었습니다.
- @OneToMany 테스트로 실제 DB와 엔티티가 다름으로써, 발생하는 문제에 대해 알 수 있었습니다.
- List와 Set의 자료 구조에 따라 다르게 동작하는 `Hibernate`의 동작을 알 수 있었습니다.

관계를 정의할 수 없는 엔티티에 대해 매우 주의하고, 엔티티와 DB를 다르게 가져가는 것도 주의해야 합니다.   
간단한 예제에서 조차 쿼리가 어떻게 나올지 예상하기 힘들었으므로, 복잡한 구조를 가지게 된다면 문제 지점을 찾기 더욱 어려울 수 있습니다.   
기본적으로 @OneToMany(Many가 관계의 주인), List 필드를 사용하고 ManyToMany, OneToMany(One이 관계 주인), Set 필드는 특별한 이유가 있을
때에만 제한적으로 사용할 것입니다.

## 참조

- [Collection type으로 Set 대신 List를 사용하는 이유 - 인프런 김영한](https://www.inflearn.com/community/questions/321256/collection-type%EC%9C%BC%EB%A1%9C-set-%EB%8C%80%EC%8B%A0-list%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EC%9E%88%EB%8A%94%EC%A7%80%EC%9A%94)

